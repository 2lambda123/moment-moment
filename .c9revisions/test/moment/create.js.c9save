{"ts":1349701291011,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var moment = require(\"../../moment\");\n\nexports.create = {\n    \"array\" : function(test) {\n        test.expect(8);\n        test.ok(moment([2010]).toDate() instanceof Date, \"[2010]\");\n        test.ok(moment([2010, 1]).toDate() instanceof Date, \"[2010, 1]\");\n        test.ok(moment([2010, 1, 12]).toDate() instanceof Date, \"[2010, 1, 12]\");\n        test.ok(moment([2010, 1, 12, 1]).toDate() instanceof Date, \"[2010, 1, 12, 1]\");\n        test.ok(moment([2010, 1, 12, 1, 1]).toDate() instanceof Date, \"[2010, 1, 12, 1, 1]\");\n        test.ok(moment([2010, 1, 12, 1, 1, 1]).toDate() instanceof Date, \"[2010, 1, 12, 1, 1, 1]\");\n        test.ok(moment([2010, 1, 12, 1, 1, 1, 1]).toDate() instanceof Date, \"[2010, 1, 12, 1, 1, 1, 1]\");\n        test.equal(+moment(new Date(2010, 1, 14, 15, 25, 50, 125)), +moment([2010, 1, 14, 15, 25, 50, 125]), \"constructing with array === constructing with new Date()\");\n        test.done();\n    },\n\n    \"number\" : function(test) {\n        test.expect(3);\n        test.ok(moment(1000).toDate() instanceof Date, \"1000\");\n        test.ok((moment(1000).valueOf() === 1000), \"testing valueOf\");\n        test.ok((moment.utc(1000).valueOf() === 1000), \"testing valueOf\");\n        test.done();\n    },\n\n    \"unix\" : function(test) {\n        test.expect(8);\n        test.equal(moment.unix(1).valueOf(), 1000, \"1 unix timestamp == 1000 Date.valueOf\");\n        test.equal(moment(1000).unix(), 1, \"1000 Date.valueOf == 1 unix timestamp\");\n        test.equal(moment.unix(1000).valueOf(), 1000000, \"1000 unix timestamp == 1000000 Date.valueOf\");\n        test.equal(moment(1500).unix(), 1, \"1500 Date.valueOf == 1 unix timestamp\");\n        test.equal(moment(1900).unix(), 1, \"1900 Date.valueOf == 1 unix timestamp\");\n        test.equal(moment(2100).unix(), 2, \"2100 Date.valueOf == 2 unix timestamp\");\n        test.equal(moment(1333129333524).unix(), 1333129333, \"1333129333524 Date.valueOf == 1333129333 unix timestamp\");\n        test.equal(moment(1333129333524000).unix(), 1333129333524, \"1333129333524000 Date.valueOf == 1333129333524 unix timestamp\");\n        test.done();\n    },\n\n    \"date\" : function(test) {\n        test.expect(1);\n        test.ok(moment(new Date()).toDate() instanceof Date, \"new Date()\");\n        test.done();\n    },\n\n    \"moment\" : function(test) {\n        test.expect(2);\n        test.ok(moment(moment()).toDate() instanceof Date, \"moment(moment())\");\n        test.ok(moment(moment(moment())).toDate() instanceof Date, \"moment(moment(moment()))\");\n        test.done();\n    },\n\n    \"undefined\" : function(test) {\n        test.expect(1);\n        test.ok(moment().toDate() instanceof Date, \"undefined\");\n        test.done();\n    },\n\n    \"string without format\" : function(test) {\n        test.expect(2);\n        test.ok(moment(\"Aug 9, 1995\").toDate() instanceof Date, \"Aug 9, 1995\");\n        test.ok(moment(\"Mon, 25 Dec 1995 13:30:00 GMT\").toDate() instanceof Date, \"Mon, 25 Dec 1995 13:30:00 GMT\");\n        test.done();\n    },\n\n    \"string from Date.toString\" : function(test) {\n        test.expect(1);\n        var str = (new Date()).toString();\n        test.equal(moment(str).toString(), str, \"Parsing a string from Date.prototype.toString should match moment.fn.toString\");\n        test.done();\n    },\n\n    \"string without format - json\" : function(test) {\n        test.expect(5);\n        test.equal(moment(\"Date(1325132654000)\").valueOf(), 1325132654000, \"Date(1325132654000)\");\n        test.equal(moment(\"Date(-1325132654000)\").valueOf(), -1325132654000, \"Date(-1325132654000)\");\n        test.equal(moment(\"/Date(1325132654000)/\").valueOf(), 1325132654000, \"/Date(1325132654000)/\");\n        test.equal(moment(\"/Date(1325132654000+0700)/\").valueOf(), 1325132654000, \"/Date(1325132654000+0700)/\");\n        test.equal(moment(\"/Date(1325132654000-0700)/\").valueOf(), 1325132654000, \"/Date(1325132654000-0700)/\");\n        test.done();\n    },\n\n    \"string with format dropped am/pm bug\" : function(test) {\n        moment.lang('en');\n        test.expect(3);\n\n        test.equal(moment('05/1/2012', 'MM/DD/YYYY h:m:s a').format('MM/DD/YYYY'), '05/01/2012', 'should not break if am/pm is left off from the parsing tokens');\n        test.equal(moment('05/1/2012 12:25:00 am', 'MM/DD/YYYY h:m:s a').format('MM/DD/YYYY'), '05/01/2012', 'should not break if am/pm is left off from the parsing tokens');\n        test.equal(moment('05/1/2012 12:25:00 pm', 'MM/DD/YYYY h:m:s a').format('MM/DD/YYYY'), '05/01/2012', 'should not break if am/pm is left off from the parsing tokens');\n\n        test.done();\n    },\n\n    \"empty string with formats\" : function(test) {\n        test.expect(3);\n\n        test.equal(moment(' ', 'MM').format('YYYY-MM-DD HH:mm:ss'), '0000-01-01 00:00:00', 'should not break if input is an empty string');\n        test.equal(moment(' ', 'DD').format('YYYY-MM-DD HH:mm:ss'), '0000-01-01 00:00:00', 'should not break if input is an empty string');\n        test.equal(moment(' ', ['MM', \"DD\"]).format('YYYY-MM-DD HH:mm:ss'), '0000-01-01 00:00:00', 'should not break if input is an empty string');\n\n        test.done();\n    },\n\n    \"matching am/pm\" : function(test) {\n        test.expect(1);\n\n        test.equal(moment('2012-09-03T03:00PM', 'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00PM', 'am/pm should parse correctly even if the input string contains other letters');\n\n        test.done();\n    },\n\n    \"string with format\" : function(test) {\n        moment.lang('en');\n        var a = [\n                ['MM-DD-YYYY',          '12-02-1999'],\n                ['DD-MM-YYYY',          '12-02-1999'],\n                ['DD/MM/YYYY',          '12/02/1999'],\n                ['DD_MM_YYYY',          '12_02_1999'],\n                ['DD:MM:YYYY',          '12:02:1999'],\n                ['D-M-YY',              '2-2-99'],\n                ['YY',                  '99'],\n                ['DDD-YYYY',            '300-1999'],\n                ['DD-MM-YYYY h:m:s',    '12-02-1999 2:45:10'],\n                ['DD-MM-YYYY h:m:s a',  '12-02-1999 2:45:10 am'],\n                ['DD-MM-YYYY h:m:s a',  '12-02-1999 2:45:10 pm'],\n                ['h:mm a',              '12:00 pm'],\n                ['h:mm a',              '12:30 pm'],\n                ['h:mm a',              '12:00 am'],\n                ['h:mm a',              '12:30 am'],\n                ['HH:mm',               '12:00'],\n                ['YYYY-MM-DDTHH:mm:ss', '2011-11-11T11:11:11'],\n                ['MM-DD-YYYY \\\\M',      '12-02-1999 M'],\n                ['ddd MMM DD HH:mm:ss YYYY', 'Tue Apr 07 22:52:51 2009'],\n                ['HH:mm:ss',            '12:00:00'],\n                ['HH:mm:ss',            '12:30:00'],\n                ['HH:mm:ss',            '00:00:00'],\n                ['HH:mm:ss S',          '00:30:00 1'],\n                ['HH:mm:ss SS',         '00:30:00 12'],\n                ['HH:mm:ss SSS',        '00:30:00 123'],\n                ['HH:mm:ss S',          '00:30:00 7'],\n                ['HH:mm:ss SS',         '00:30:00 78'],\n                ['HH:mm:ss SSS',        '00:30:00 789']\n            ],\n            i;\n\n        test.expect(a.length);\n        for (i = 0; i < a.length; i++) {\n            test.equal(moment(a[i][1], a[i][0]).format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n        test.done();\n    },\n\n    \"string with format no separators\" : function(test) {\n        moment.lang('en');\n        var a = [\n                ['MMDDYYYY',          '12021999'],\n                ['DDMMYYYY',          '12021999'],\n                ['YYYYMMDD',          '19991202']\n            ],i;\n\n        test.expect(a.length);\n\n        for (i = 0; i < a.length; i++) {\n            test.equal(moment(a[i][1], a[i][0]).format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n\n        test.done();\n    },\n\n    \"string with format (timezone)\" : function(test) {\n        test.expect(8);\n        test.equal(moment('5 -0700', 'H ZZ').toDate().getUTCHours(), 12, 'parse hours \"5 -0700\" ---> \"H ZZ\"');\n        test.equal(moment('5 -07:00', 'H Z').toDate().getUTCHours(), 12, 'parse hours \"5 -07:00\" ---> \"H Z\"');\n        test.equal(moment('5 -0730', 'H ZZ').toDate().getUTCMinutes(), 30, 'parse hours \"5 -0730\" ---> \"H ZZ\"');\n        test.equal(moment('5 -07:30', 'H Z').toDate().getUTCMinutes(), 30, 'parse hours \"5 -07:30\" ---> \"H Z\"');\n        test.equal(moment('5 +0100', 'H ZZ').toDate().getUTCHours(), 4, 'parse hours \"5 +0100\" ---> \"H ZZ\"');\n        test.equal(moment('5 +01:00', 'H Z').toDate().getUTCHours(), 4, 'parse hours \"5 +01:00\" ---> \"H Z\"');\n        test.equal(moment('5 +0130', 'H ZZ').toDate().getUTCMinutes(), 30, 'parse hours \"5 +0130\" ---> \"H ZZ\"');\n        test.equal(moment('5 +01:30', 'H Z').toDate().getUTCMinutes(), 30, 'parse hours \"5 +01:30\" ---> \"H Z\"');\n        test.done();\n    },\n\n    \"string with format (timezone offset)\" : function(test) {\n        test.expect(4);\n        var a = new Date(Date.UTC(2011, 0, 1, 1));\n        var b = moment('2011 1 1 0 -01:00', 'YYYY MM DD HH Z');\n        test.equal(a.getHours(), b.hours(), 'date created with utc == parsed string with timezone offset');\n        test.equal(+a, +b, 'date created with utc == parsed string with timezone offset');\n        var c = moment('2011 2 1 10 -05:00', 'YYYY MM DD HH Z');\n        var d = moment('2011 2 1 8 -07:00', 'YYYY MM DD HH Z');\n        test.equal(c.hours(), d.hours(), '10 am central time == 8 am pacific time');\n        var e = moment.utc('Fri, 20 Jul 2012 17:15:00', 'ddd, DD MMM YYYY HH:mm:ss');\n        var f = moment.utc('Fri, 20 Jul 2012 10:15:00 -0700', 'ddd, DD MMM YYYY HH:mm:ss ZZ');\n        test.equal(e.hours(), f.hours(), 'parse timezone offset in utc');\n        test.done();\n    },\n\n    \"string with array of formats\" : function(test) {\n        test.expect(3);\n        test.equal(moment('13-02-1999', ['MM-DD-YYYY', 'DD-MM-YYYY']).format('MM DD YYYY'), '02 13 1999', 'switching month and day');\n        test.equal(moment('02-13-1999', ['MM/DD/YYYY', 'YYYY-MM-DD', 'MM-DD-YYYY']).format('MM DD YYYY'), '02 13 1999', 'year last');\n        test.equal(moment('1999-02-13', ['MM/DD/YYYY', 'YYYY-MM-DD', 'MM-DD-YYYY']).format('MM DD YYYY'), '02 13 1999', 'year first');\n        test.done();\n    },\n\n    \"string with format - years\" : function(test) {\n        test.expect(2);\n        test.equal(moment('71', 'YY').format('YYYY'), '1971', '71 > 1971');\n        test.equal(moment('69', 'YY').format('YYYY'), '2069', '69 > 2069');\n        test.done();\n    },\n\n    \"implicit cloning\" : function(test) {\n        test.expect(2);\n        var momentA = moment([2011, 10, 10]);\n        var momentB = moment(momentA);\n        momentA.month(5);\n        test.equal(momentB.month(), 10, \"Calling moment() on a moment will create a clone\");\n        test.equal(momentA.month(), 5, \"Calling moment() on a moment will create a clone\");\n        test.done();\n    },\n\n    \"explicit cloning\" : function(test) {\n        test.expect(2);\n        var momentA = moment([2011, 10, 10]);\n        var momentB = momentA.clone();\n        momentA.month(5);\n        test.equal(momentB.month(), 10, \"Calling moment() on a moment will create a clone\");\n        test.equal(momentA.month(), 5, \"Calling moment() on a moment will create a clone\");\n        test.done();\n    },\n\n    \"cloning carrying over utc mode\" : function(test) {\n        test.expect(8);\n\n        test.equal(moment().local().clone()._isUTC, false, \"An explicit cloned local moment should have _isUTC == false\");\n        test.equal(moment().utc().clone()._isUTC, true, \"An cloned utc moment should have _isUTC == true\");\n        test.equal(moment().clone()._isUTC, false, \"An explicit cloned local moment should have _isUTC == false\");\n        test.equal(moment.utc().clone()._isUTC, true, \"An explicit cloned utc moment should have _isUTC == true\");\n        test.equal(moment(moment().local())._isUTC, false, \"An implicit cloned local moment should have _isUTC == false\");\n        test.equal(moment(moment().utc())._isUTC, true, \"An implicit cloned utc moment should have _isUTC == true\");\n        test.equal(moment(moment())._isUTC, false, \"An implicit cloned local moment should have _isUTC == false\");\n        test.equal(moment(moment.utc())._isUTC, true, \"An implicit cloned utc moment should have _isUTC == true\");\n\n        test.done();\n    },\n\n    \"parsing iso\" : function(test) {\n        var offset = moment([2011, 9, 08]).zone();\n        var pad = function(input) {\n            if (input < 10) {\n                return '0' + input;\n            }\n            return '' + input;\n        }\n        var hourOffset = (offset > 0) ? Math.floor(offset / 60) : Math.ceil(offset / 60);\n        var minOffset = offset - (hourOffset * 60);\n        var tz = (offset > 0) ? '-' + pad(hourOffset) + ':' + pad(minOffset) : '+' + pad(-hourOffset) + ':' + pad(-minOffset);\n        var tz2 = tz.replace(':', '');\n        var formats = [\n            ['2011-10-08',                    '2011-10-08T00:00:00.000' + tz],\n            ['2011-10-08T18',                 '2011-10-08T18:00:00.000' + tz],\n            ['2011-10-08T18:04',              '2011-10-08T18:04:00.000' + tz],\n            ['2011-10-08T18:04:20',           '2011-10-08T18:04:20.000' + tz],\n            ['2011-10-08T18:04' + tz,         '2011-10-08T18:04:00.000' + tz],\n            ['2011-10-08T18:04:20' + tz,      '2011-10-08T18:04:20.000' + tz],\n            ['2011-10-08T18:04' + tz2,        '2011-10-08T18:04:00.000' + tz],\n            ['2011-10-08T18:04:20' + tz2,     '2011-10-08T18:04:20.000' + tz],\n            ['2011-10-08T18:04:20.1' + tz2,   '2011-10-08T18:04:20.100' + tz],\n            ['2011-10-08T18:04:20.11' + tz2,  '2011-10-08T18:04:20.110' + tz],\n            ['2011-10-08T18:04:20.111' + tz2, '2011-10-08T18:04:20.111' + tz]\n        ];\n        test.expect(formats.length);\n        for (var i = 0; i < formats.length; i++) {\n            test.equal(formats[i][1], moment(formats[i][0]).format('YYYY-MM-DDTHH:mm:ss.SSSZ'), \"moment should be able to parse ISO \" + formats[i][0]);\n        }\n        test.done();\n    },\n\n    \"parsing iso Z timezone\" : function(test) {\n        var i,\n            formats = [\n            ['2011-10-08T18:04Z',             '2011-10-08T18:04:00.000+00:00'],\n            ['2011-10-08T18:04:20Z',          '2011-10-08T18:04:20.000+00:00'],\n            ['2011-10-08T18:04:20.111Z',      '2011-10-08T18:04:20.111+00:00']\n        ];\n        test.expect(formats.length);\n        for (i = 0; i < formats.length; i++) {\n            test.equal(moment.utc(formats[i][0]).format('YYYY-MM-DDTHH:mm:ss.SSSZ'), formats[i][1], \"moment should be able to parse ISO \" + formats[i][0]);\n        }\n        test.done();\n    },\n\n    \"parsing iso Z timezone into local\" : function(test) {\n        test.expect(1);\n\n        var m = moment('2011-10-08T18:04:20.111Z');\n\n        test.equal(m.utc().format('YYYY-MM-DDTHH:mm:ss.SSS'), '2011-10-08T18:04:20.111', \"moment should be able to parse ISO 2011-10-08T18:04:20.111Z\");\n\n        test.done();\n    },\n\n    \"null\" : function(test) {\n        test.expect(3);\n        test.equal(moment(''), null, \"Calling moment('')\");\n        test.equal(moment(null), null, \"Calling moment(null)\");\n        test.equal(moment('', 'YYYY-MM-DD'), null, \"Calling moment('', 'YYYY-MM-DD')\");\n        test.done();\n    },\n\n    \"first century\" : function(test) {\n        test.expect(6);\n        test.equal(moment([0, 0, 1]).format(\"YYYY-MM-DD\"), \"0000-01-01\", \"Year AD 0\");\n        test.equal(moment([99, 0, 1]).format(\"YYYY-MM-DD\"), \"0099-01-01\", \"Year AD 99\");\n        test.equal(moment([999, 0, 1]).format(\"YYYY-MM-DD\"), \"0999-01-01\", \"Year AD 999\");\n        test.equal(moment('0 1 1', 'YYYY MM DD').format(\"YYYY-MM-DD\"), \"0000-01-01\", \"Year AD 0\");\n        test.equal(moment('99 1 1', 'YYYY MM DD').format(\"YYYY-MM-DD\"), \"0099-01-01\", \"Year AD 99\");\n        test.equal(moment('999 1 1', 'YYYY MM DD').format(\"YYYY-MM-DD\"), \"0999-01-01\", \"Year AD 999\");\n        test.done();\n    },\n\n    \"six digit years\" : function(test) {\n        test.expect(2);\n        test.equal(moment([-270000, 0, 1]).format(\"YYYY-MM-DD\"), \"-270000-01-01\", \"format BC 270,000\");\n        test.equal(moment([ 270000, 0, 1]).format(\"YYYY-MM-DD\"), \"270000-01-01\", \"format AD 270,000\");\n        test.done();\n    }\n};\n"]],"start1":0,"start2":0,"length1":0,"length2":16184}]],"length":16184}
{"contributors":[],"silentsave":false,"ts":1349702430159,"patch":[[{"diffs":[[0,"11:11:11'],\n"],[1,"                ['YYYY-MM-DD HH:mm:ss', '2012-10-08 21:20:30'],\n"],[0,"            "]],"start1":6388,"start2":6388,"length1":24,"length2":88}]],"length":16248,"saved":false}
