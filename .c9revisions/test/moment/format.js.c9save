{"ts":1349701267323,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var moment = require(\"../../moment\");\n\nexports.format = {\n    \"format YY\" : function(test) {\n        test.expect(1);\n\n        var b = moment(new Date(2009, 1, 14, 15, 25, 50, 125));\n        test.equal(b.format('YY'), '09', 'YY ---> 09');\n        test.done();\n    },\n\n    \"format escape brackets\" : function(test) {\n        test.expect(9);\n\n        var b = moment(new Date(2009, 1, 14, 15, 25, 50, 125));\n        test.equal(b.format('[day]'), 'day', 'Single bracket');\n        test.equal(b.format('[day] YY [YY]'), 'day 09 YY', 'Double bracket');\n        test.equal(b.format('[YY'), '[09', 'Un-ended bracket');\n        test.equal(b.format('[[YY]]'), '[YY]', 'Double nested brackets');\n        test.equal(b.format('[[]'), '[', 'Escape open bracket');\n        test.equal(b.format('[Last]'), 'Last', 'localized tokens');\n        test.equal(b.format('[L] L'), 'L 02/14/2009', 'localized tokens with escaped localized tokens');\n        test.equal(b.format('[L LL LLL LLLL aLa]'), 'L LL LLL LLLL aLa', 'localized tokens with escaped localized tokens');\n        test.equal(b.format('[LLL] LLL'), 'LLL February 14 2009 3:25 PM', 'localized tokens with escaped localized tokens (recursion)');\n        test.done();\n    },\n\n    \"format milliseconds\" : function(test) {\n        test.expect(6);\n        var b = moment(new Date(2009, 1, 14, 15, 25, 50, 123));\n        test.equal(b.format('S'), '1', 'Deciseconds');\n        test.equal(b.format('SS'), '12', 'Centiseconds');\n        test.equal(b.format('SSS'), '123', 'Milliseconds');\n        b.milliseconds(789);\n        test.equal(b.format('S'), '7', 'Deciseconds');\n        test.equal(b.format('SS'), '78', 'Centiseconds');\n        test.equal(b.format('SSS'), '789', 'Milliseconds');\n        test.done();\n    },\n\n    \"format timezone\" : function(test) {\n        test.expect(2);\n\n        var b = moment(new Date(2010, 1, 14, 15, 25, 50, 125));\n        var explanation = 'moment().format(\"z\") = ' + b.format('z') + ' It should be something like \"PST\"'\n        if (moment().zone() === -60) {\n            explanation += \"For UTC+1 this is a known issue, see https://github.com/timrwood/moment/issues/162\";\n        }\n        test.ok(b.format('Z').match(/^[\\+\\-]\\d\\d:\\d\\d$/), b.format('Z') + ' should be something like \"+07:30\"');\n        test.ok(b.format('ZZ').match(/^[\\+\\-]\\d{4}$/), b.format('ZZ') + ' should be something like \"+0700\"');\n        test.done();\n    },\n\n    \"format multiple with zone\" : function(test) {\n        test.expect(1);\n\n        var b = moment('2012-10-08 -1200', ['YYYY ZZ', 'YYYY-MM-DD ZZ']);\n        test.equals(b.format('YYYY-MM'), '2012-10', 'Parsing multiple formats should not crash with different sized formats');\n        test.done();\n    },\n\n    \"isDST\" : function(test) {\n        test.expect(2);\n\n        var janOffset = new Date(2011, 0, 1).getTimezoneOffset(),\n            julOffset = new Date(2011, 6, 1).getTimezoneOffset(),\n            janIsDst = janOffset < julOffset,\n            julIsDst = julOffset < janOffset,\n            jan1 = moment([2011]),\n            jul1 = moment([2011, 6]);\n\n        if (janIsDst && julIsDst) {\n            test.ok(0, 'January and July cannot both be in DST');\n            test.ok(0, 'January and July cannot both be in DST');\n        } else if (janIsDst) {\n            test.ok(jan1.isDST(), 'January 1 is DST');\n            test.ok(!jul1.isDST(), 'July 1 is not DST');\n        } else if (julIsDst) {\n            test.ok(!jan1.isDST(), 'January 1 is not DST');\n            test.ok(jul1.isDST(), 'July 1 is DST');\n        } else {\n            test.ok(!jan1.isDST(), 'January 1 is not DST');\n            test.ok(!jul1.isDST(), 'July 1 is not DST');\n        }\n        test.done();\n    },\n\n    \"zone\" : function(test) {\n        test.expect(3);\n\n        if (moment().zone() > 0) {\n            test.ok(moment().format('ZZ').indexOf('-') > -1, 'When the zone() offset is greater than 0, the ISO offset should be less than zero');\n        }\n        if (moment().zone() < 0) {\n            test.ok(moment().format('ZZ').indexOf('+') > -1, 'When the zone() offset is less than 0, the ISO offset should be greater than zero');\n        }\n        if (moment().zone() == 0) {\n            test.ok(moment().format('ZZ').indexOf('+') > -1, 'When the zone() offset is equal to 0, the ISO offset should be positive zero');\n        }\n        if (moment().zone() === 0) {\n           test.equal(moment().zone(), 0, 'moment.fn.zone should be a multiple of 15 (was ' + moment().zone() + ')');\n        } else {\n           test.equal(moment().zone() % 15, 0, 'moment.fn.zone should be a multiple of 15 (was ' + moment().zone() + ')');\n        }\n        test.equal(moment().zone(), new Date().getTimezoneOffset(), 'zone should equal getTimezoneOffset');\n        test.done();\n    },\n\n    \"default format\" : function(test) {\n        test.expect(1);\n        var isoRegex = /\\d{4}.\\d\\d.\\d\\dT\\d\\d.\\d\\d.\\d\\d[\\+\\-]\\d\\d:\\d\\d/;\n        test.ok(isoRegex.exec(moment().format()), \"default format (\" + moment().format() + \") should match ISO\");\n        test.done();\n    }\n};\n"]],"start1":0,"start2":0,"length1":0,"length2":5036}]],"length":5036}
